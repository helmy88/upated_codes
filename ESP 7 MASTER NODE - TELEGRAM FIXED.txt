// ESP 1: MASTER NODE - TELEGRAM FIXED VERSION (Final Optimized & Cleaned)
// Cleaned of all stray unicode characters (NBSP, 0xC2 0xA0)

#include <Keypad.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <ESP8266WiFi.h>
#include <espnow.h>
#include <WiFiClientSecure.h>
#include <UniversalTelegramBot.h>
#include <ArduinoJson.h>
#include <time.h>

// --- CONFIGURATION ---
#define WIFI_SSID "putez"
#define WIFI_PASSWORD "zulaikha"

// --- TELEGRAM CREDENTIALS ---
#define BOT_TOKEN "8527056749:AAFZyQRBSGjPq_EFg0Wa58JTS4s-FnT5rD4"
#define CHAT_ID "628920149"

// --- SSL CLIENT ---
BearSSL::WiFiClientSecure client;
UniversalTelegramBot bot(BOT_TOKEN, client);

// --- TARGET MAC ADDRESS (SLAVE) ---
uint8_t slaveMac[] = {0x84, 0x0D, 0x8E, 0xA7, 0xAE, 0x54};

// --- DATA STRUCTURE ---
typedef struct struct_message {
    bool commandUnlock;
    int rfidStatus;
} struct_message;

struct_message outgoingData;

// --- FLAGS ---
volatile bool telegramNeeded = false;
volatile int telegramType = 0;

// --- LCD & KEYPAD ---
LiquidCrystal_I2C lcd(0x27, 16, 2);

const byte ROWS = 4;
const byte COLS = 4;
char keys[ROWS][COLS] = {
    {'1','4','7','*'},
    {'2','5','8','0'},
    {'3','6','9','#'},
    {'A','B','C','D'}
};

byte rowPins[ROWS] = {D1, D2, D5, D6};
byte colPins[COLS] = {D7, D0, D3, D4};

Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

String password = "12345678";
String inputPassword = "";

// --- FUNCTIONS ---

void showMessage(String line1, String line2) {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print(line1);
    lcd.setCursor(0, 1);
    lcd.print(line2);
}

void sendTelegramAlert(String message) {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("WiFi disconnected - cannot send telegram.");
        return;
    }

    time_t now = time(nullptr);
    if (now < 24 * 3600) {
        Serial.println("Time not synced - SSL will fail.");
        return;
    }

    uint32_t freeHeap = ESP.getFreeHeap();
    Serial.printf("Free Heap: %d bytes\n", freeHeap);

    if (freeHeap < 15000) {
        Serial.println("Low memory - delaying telegram.");
        return;
    }

    Serial.println("Sending Telegram...");
    Serial.println("Message: " + message);

    if (client.connected()) {
        client.stop();
        delay(100);
    }

    bool success = false;
    for (int attempt = 1; attempt <= 2; attempt++) {
        Serial.printf("Attempt %d...\n", attempt);

        success = bot.sendMessage(CHAT_ID, message, "");

        if (success) {
            Serial.println("Telegram sent successfully!");
            break;
        } else {
            Serial.printf("Attempt %d failed. SSL Error: %d\n",
                          attempt, client.getLastSSLError());
            if (attempt < 2) delay(2000);
        }
    }

    if (!success) {
        Serial.println("All attempts failed. Check token, network, or bot.");
    }

    client.stop();
    delay(100);
}

void sendUnlockCommand() {
    outgoingData.commandUnlock = true;
    outgoingData.rfidStatus = 0;
    esp_now_send(slaveMac, (uint8_t *)&outgoingData, sizeof(outgoingData));
}

void OnDataSent(uint8_t *mac_addr, uint8_t sendStatus) {
    // Optional debug: Serial.printf("ESP-NOW Sent: %d\n", sendStatus);
}

void OnDataRecv(uint8_t *mac, uint8_t *incomingData, uint8_t len) {
    struct_message receivedData;
    memcpy(&receivedData, incomingData, sizeof(receivedData));

    if (receivedData.rfidStatus == 1) {
        telegramType = 1;
        telegramNeeded = true;
    } else if (receivedData.rfidStatus == 2) {
        telegramType = 2;
        telegramNeeded = true;
    }
}

void checkPassword() {
    if (inputPassword == password) {
        showMessage("PIN ACCEPTED", "Unlocking...");
        sendUnlockCommand();
        sendTelegramAlert("Door Unlocked via PIN");
        delay(3000);
    } else {
        showMessage("ACCESS DENIED", "Try Again");
        sendTelegramAlert("Failed PIN Attempt");
        delay(2000);
    }

    showMessage("Enter PIN:", "");
    inputPassword = "";
}

void syncTime() {
    showMessage("Syncing Time...", "Please Wait");
    Serial.println("Syncing NTP time...");

    configTime(8 * 3600, 0, "pool.ntp.org", "time.nist.gov");

    time_t now = time(nullptr);
    int retries = 0;

    while (now < 24 * 3600 && retries < 60) {
        delay(500);
        Serial.print(".");
        now = time(nullptr);
        retries++;
    }

    if (now > 24 * 3600) {
        Serial.println("\nTime synced!");
        showMessage("Time Synced!", "");
    } else {
        Serial.println("\nTime sync failed.");
        showMessage("Time Error", "Telegram Disabled");
    }
}

void setup() {
    Serial.begin(115200);
    delay(100);
    Serial.println("\nESP8266 Master Booting...");

    lcd.init();
    lcd.backlight();
    showMessage("Booting...", "WiFi Init");

    WiFi.mode(WIFI_STA);
    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);

    client.setInsecure();
    client.setBufferSizes(2048, 512);

    int timeout = 0;
    while (WiFi.status() != WL_CONNECTED && timeout < 40) {
        delay(500);
        Serial.print(".");
        timeout++;
    }

    if (WiFi.status() == WL_CONNECTED) {
        Serial.println("\nWiFi Connected.");
        showMessage("WiFi Connected", "Syncing Time...");
        syncTime();
    } else {
        Serial.println("\nWiFi Failed.");
        showMessage("WiFi Failed", "Offline Mode");
    }

    if (esp_now_init() != 0) {
        Serial.println("ESP-NOW init failed!");
        return;
    }

    esp_now_set_self_role(ESP_NOW_ROLE_COMBO);
    esp_now_add_peer(slaveMac, ESP_NOW_ROLE_COMBO, 1, NULL, 0);
    esp_now_register_send_cb(OnDataSent);
    esp_now_register_recv_cb(OnDataRecv);

    Serial.println("ESP-NOW Initialized");

    if (WiFi.status() == WL_CONNECTED && time(nullptr) > 24 * 3600) {
        sendTelegramAlert("System Started - Master Online");
    }

    showMessage("System Ready", "Enter PIN:");
}

void loop() {
    if (telegramNeeded) {
        telegramNeeded = false;

        if (telegramType == 1) {
            showMessage("RFID SCANNED", "ACCESS GRANTED");
            sendTelegramAlert("Door Unlocked via RFID");
        } else if (telegramType == 2) {
            showMessage("RFID SCANNED", "ACCESS DENIED!");
            sendTelegramAlert("Unauthorized RFID Scan!");
        }

        delay(2000);
        showMessage("Enter PIN:", "");
        inputPassword = "";
    }

    char key = keypad.getKey();
    if (key) {
        if (key == '#') {
            checkPassword();
        } else if (key == '*') {
            inputPassword = "";
            showMessage("Enter PIN:", "");
        } else if (key >= '0' && key <= '9') {
            if (inputPassword.length() < 16) {
                inputPassword += key;
                lcd.setCursor(0, 1);
                String stars = "";
                for (int i = 0; i < inputPassword.length(); i++) stars += "*";
                lcd.print(stars);
            }
        }
    }

    yield();
}
