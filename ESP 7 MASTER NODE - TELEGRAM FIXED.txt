// ESP 1: MASTER NODE - TELEGRAM FIXED VERSION (Final Optimized Code)
// This version includes the fix for the BearSSL/Telegram error and enhanced logging.

#include <Keypad.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <ESP8266WiFi.h>
#include <espnow.h>
#include <WiFiClientSecure.h>
#include <UniversalTelegramBot.h>
#include <ArduinoJson.h>
#include <time.h>

// --- CONFIGURATION ---
// IMPORTANT: REPLACE WITH YOUR OWN WIFI DETAILS
#define WIFI_SSID "putez"
#define WIFI_PASSWORD "zulaikha"

// --- TELEGRAM CREDENTIALS ---
// NOTE: Ensure you have sent the /start command to your bot from the CHAT_ID account!
#define BOT_TOKEN "8527056749:AAFZyQRBSGjPq_EFg0Wa58JTS4s-FnT5rD4"
#define CHAT_ID "628920149"

// --- SSL CLIENT ---
BearSSL::WiFiClientSecure client;
UniversalTelegramBot bot(BOT_TOKEN, client);

// --- TARGET MAC ADDRESS (SLAVE) ---
uint8_t slaveMac[] = {0x84, 0x0D, 0x8E, 0xA7, 0xAE, 0x54};

// --- DATA STRUCTURE ---
typedef struct struct_message {
Â  Â  bool commandUnlock;
Â  Â  int rfidStatus;
} struct_message;

struct_message outgoingData;

// --- FLAGS ---
volatile bool telegramNeeded = false;
volatile int telegramType = 0;

// --- LCD & KEYPAD ---
LiquidCrystal_I2C lcd(0x27, 16, 2);

const byte ROWS = 4;
const byte COLS = 4;
char keys[ROWS][COLS] = {
Â  Â  {'1','4','7','*'},
Â  Â  {'2','5','8','0'},
Â  Â  {'3','6','9','#'},
Â  Â  {'A','B','C','D'}
};
byte rowPins[ROWS] = {D1, D2, D5, D6};
byte colPins[COLS] = {D7, D0, D3, D4};
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

String password = "12345678";
String inputPassword = "";

// --- FUNCTIONS ---

/**
 * @brief Displays a message on the 16x2 LCD.
 */
void showMessage(String line1, String line2) {
Â  Â  lcd.clear();
Â  Â  lcd.setCursor(0,0);
Â  Â  lcd.print(line1);
Â  Â  lcd.setCursor(0,1);
Â  Â  lcd.print(line2);
}

/**
 * @brief Sends a message to the Telegram bot with retries and checks.
 */
void sendTelegramAlert(String message) {
Â  Â  // Pre-flight checks for reliable Telegram operation
Â  Â  if (WiFi.status() != WL_CONNECTED) {
Â  Â  Â  Â  Serial.println("âŒ WiFi Disconnected - Cannot send Telegram.");
Â  Â  Â  Â  return;
Â  Â  }
Â  Â Â 
Â  Â  time_t now = time(nullptr);
Â  Â  if (now < 24 * 3600) {
Â  Â  Â  Â  Serial.println("âŒ Time not synced - Cannot send Telegram (SSL failure likely).");
Â  Â  Â  Â  return;
Â  Â  }
Â  Â Â 
Â  Â  // Memory check (Ensuring enough heap for SSL handshake)
Â  Â  uint32_t freeHeap = ESP.getFreeHeap();
Â  Â  Serial.printf("Free Heap: %d bytes\n", freeHeap);
Â  Â Â 
Â  Â  if (freeHeap < 15000) {
Â  Â  Â  Â  Serial.println("âŒ Low Memory (<15KB) - Postponing Telegram send.");
Â  Â  Â  Â  return;
Â  Â  }
Â  Â Â 
Â  Â  Serial.println("ğŸ“¤ Sending Telegram...");
Â  Â  Serial.println("Message: " + message);
Â  Â Â 
Â  Â  // Ensure client is stopped before starting a new transaction
Â  Â  if (client.connected()) {
Â  Â  Â  Â  client.stop();
Â  Â  Â  Â  delay(100);
Â  Â  }
Â  Â Â 
Â  Â  // Attempt to send with retry
Â  Â  bool success = false;
Â  Â  for (int attempt = 1; attempt <= 2; attempt++) {
Â  Â  Â  Â  Serial.printf("Attempt %d...\n", attempt);
Â  Â  Â  Â Â 
Â  Â  Â  Â  success = bot.sendMessage(CHAT_ID, message, "");
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (success) {
Â  Â  Â  Â  Â  Â  Serial.println("âœ… Telegram SENT!");
Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  // FIX: client.getLastSSLError() returns an int, not a string
Â  Â  Â  Â  Â  Â  Serial.printf("âŒ Attempt %d failed. SSL Error Code: %d\n", attempt, client.getLastSSLError());
Â  Â  Â  Â  Â  Â  if (attempt < 2) {
Â  Â  Â  Â  Â  Â  Â  Â  delay(2000); // Wait before retry
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  if (!success) {
Â  Â  Â  Â  Serial.println("âŒ All attempts failed. Possible network, bot, or token error.");
Â  Â  }
Â  Â Â 
Â  Â  // Cleanup
Â  Â  client.stop();
Â  Â  delay(100);
}

/**
 * @brief Sends the unlock command via ESP-NOW to the Slave.
 */
void sendUnlockCommand() {
Â  Â  outgoingData.commandUnlock = true;
Â  Â  outgoingData.rfidStatus = 0;
Â  Â  esp_now_send(slaveMac, (uint8_t *) &outgoingData, sizeof(outgoingData));
}

// --- ESP-NOW CALLBACKS ---
void OnDataSent(uint8_t *mac_addr, uint8_t sendStatus) { 
    // This callback confirms if the message was successfully sent to the slave.
    // Serial.printf("Last Packet Send Status: %d\n", sendStatus);
}

/**
 * @brief Receives data from the Slave node (e.g., RFID status).
 */
void OnDataRecv(uint8_t * mac, uint8_t * incomingData, uint8_t len) {
Â  Â  struct_message receivedData;
Â  Â  memcpy(&receivedData, incomingData, sizeof(receivedData));
Â  Â Â 
Â  Â  if (receivedData.rfidStatus == 1) { // Success/Granted
Â  Â  Â  Â  telegramType = 1;
Â  Â  Â  Â  telegramNeeded = true;
Â  Â  }
Â  Â  else if (receivedData.rfidStatus == 2) { // Failed/Denied
Â  Â  Â  Â  telegramType = 2;
Â  Â  Â  Â  telegramNeeded = true;
Â  Â  }
}

/**
 * @brief Handles PIN check logic from the Keypad.
 */
void checkPassword() {
Â  Â  if (inputPassword == password) {
Â  Â  Â  Â  showMessage("PIN ACCEPTED", "Unlocking...");
Â  Â  Â  Â  sendUnlockCommand();
Â  Â  Â  Â  sendTelegramAlert("ğŸ”“ Door Unlocked via PIN");
Â  Â  Â  Â  delay(3000);
Â  Â  Â  Â  showMessage("Enter PIN:", "");
Â  Â  } else {
Â  Â  Â  Â  showMessage("ACCESS DENIED", "Try Again");
Â  Â  Â  Â  sendTelegramAlert("âš ï¸ Failed PIN Attempt");
Â  Â  Â  Â  delay(2000);
Â  Â  Â  Â  showMessage("Enter PIN:", "");
Â  Â  }
Â  Â  inputPassword = "";
}

/**
 * @brief Synchronizes the system time using NTP for SSL/Telegram.
 */
void syncTime() {
Â  Â  showMessage("Syncing Time...", "Please Wait");
Â  Â  Serial.println("â° Setting time using SNTP (GMT+8)");
Â  Â Â 
Â  Â  // GMT+8 for Malaysia - Adjust the first parameter (8 * 3600) for your timezone
Â  Â  configTime(8 * 3600, 0, "pool.ntp.org", "time.nist.gov");
Â  Â Â 
Â  Â  time_t now = time(nullptr);
Â  Â  int retries = 0;
Â  Â Â 
Â  Â  while (now < 24 * 3600 && retries < 60) {
Â  Â  Â  Â  delay(500);
Â  Â  Â  Â  Serial.print(".");
Â  Â  Â  Â  now = time(nullptr);
Â  Â  Â  Â  retries++;
Â  Â  }
Â  Â Â 
Â  Â  if (now > 24 * 3600) {
Â  Â  Â  Â  Serial.println("\nâœ… Time Synced!");
Â  Â  Â  Â  showMessage("Time Synced!", "");
Â  Â  } else {
Â  Â  Â  Â  Serial.println("\nâŒ Time Sync FAILED - Telegram will likely fail.");
Â  Â  Â  Â  showMessage("Time Error", "Telegram Disabled");
Â  Â  }
}

void setup() {
Â  Â  Serial.begin(115200);
Â  Â  delay(100);
Â  Â  Serial.println("\n\n=== ESP8266 Master Node Booting ===");
Â  Â Â 
Â  Â  // Initialize LCD
Â  Â  lcd.init();
Â  Â  lcd.backlight();
Â  Â  showMessage("Booting...", "WiFi Init");
Â  Â Â 
Â  Â  // 1. WiFi Setup
Â  Â  WiFi.mode(WIFI_STA);
Â  Â  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
Â  Â Â 
Â  Â  // SSL SETTINGS (critical for ESP8266 Telegram)
Â  Â  client.setInsecure(); // Less secure, but required for wide compatibility on ESP8266
Â  Â  client.setBufferSizes(2048, 512);
Â  Â Â 
Â  Â  int timeout = 0;
Â  Â  while (WiFi.status() != WL_CONNECTED && timeout < 40) {
Â  Â  Â  Â  delay(500);
Â  Â  Â  Â  Serial.print(".");
Â  Â  Â  Â  timeout++;
Â  Â  }
Â  Â Â 
Â  Â  if (WiFi.status() == WL_CONNECTED) {
Â  Â  Â  Â  showMessage("WiFi Connected", "Syncing Time...");
Â  Â  Â  Â  Serial.println("\nâœ… WiFi Connected");
Â  Â  Â  Â Â 
Â  Â  Â  Â  // 2. Time Sync (Essential for SSL/Telegram)
Â  Â  Â  Â  syncTime();
Â  Â  Â  Â Â 
Â  Â  } else {
Â  Â  Â  Â  showMessage("WiFi Failed", "Offline Mode");
Â  Â  Â  Â  Serial.println("\nâŒ WiFi Failed - System operating in Offline Mode (No Telegram)");
Â  Â  }
Â  Â Â 
Â  Â  delay(500);
Â  Â Â 
Â  Â  // 3. ESP-NOW Setup
Â  Â  if (esp_now_init() != 0) {
Â  Â  Â  Â  Serial.println("âŒ ESP-NOW Init Failed");
Â  Â  Â  Â  return;
Â  Â  }
Â  Â Â 
Â  Â  esp_now_set_self_role(ESP_NOW_ROLE_COMBO);
Â  Â  esp_now_add_peer(slaveMac, ESP_NOW_ROLE_COMBO, 1, NULL, 0);
Â  Â  esp_now_register_send_cb(OnDataSent);
Â  Â  esp_now_register_recv_cb(OnDataRecv);
Â  Â Â 
Â  Â  Serial.println("âœ… ESP-NOW Initialized");
Â  Â Â 
Â  Â  // 4. Test Telegram (Only if WiFi/Time is OK)
Â  Â  if (WiFi.status() == WL_CONNECTED && time(nullptr) > 24*3600) {
Â  Â  Â  Â  Serial.println("\n--- Testing Telegram Connection ---");
Â  Â  Â  Â  sendTelegramAlert("ğŸš€ System Started - Master Online (New Bot Config)");
Â  Â  }
Â  Â Â 
Â  Â  showMessage("System Ready", "Enter PIN:");
Â  Â  Serial.println("\n=== System Ready ===\n");
}

void loop() {
Â  Â  // Handle Telegram notifications from ESP-NOW received data
Â  Â  if (telegramNeeded) {
Â  Â  Â  Â  telegramNeeded = false;
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (telegramType == 1) { // RFID Success
Â  Â  Â  Â  Â  Â  showMessage("RFID SCANNED", "ACCESS GRANTED");
Â  Â  Â  Â  Â  Â  sendTelegramAlert("âœ… Door Unlocked via RFID");
Â  Â  Â  Â  }
Â  Â  Â  Â  else if (telegramType == 2) { // RFID Failed
Â  Â  Â  Â  Â  Â  showMessage("RFID SCANNED", "ACCESS DENIED!");
Â  Â  Â  Â  Â  Â  sendTelegramAlert("ğŸš¨ Unauthorized RFID Scan!");
Â  Â  Â  Â  }
        
        // Reset display and password input after notification
Â  Â  Â  Â  delay(2000);
Â  Â  Â  Â  showMessage("Enter PIN:", "");
Â  Â  Â  Â  inputPassword = "";
Â  Â  }
Â  Â Â 
Â  Â  // Handle Keypad input
Â  Â  char key = keypad.getKey();
Â  Â  if (key) {
Â  Â  Â  Â  if (key == '#') {
Â  Â  Â  Â  Â  Â  checkPassword();
Â  Â  Â  Â  }
Â  Â  Â  Â  else if (key == '*') {
Â  Â  Â  Â  Â  Â  inputPassword = "";
Â  Â  Â  Â  Â  Â  showMessage("Enter PIN:", "");
Â  Â  Â  Â  }
Â  Â  Â  Â  else if (key >= '0' && key <= '9') { // Only process digits for PIN
Â  Â  Â  Â  Â  Â  if (inputPassword.length() < 16) {
Â  Â  Â  Â  Â  Â  Â  Â  inputPassword += key;
Â  Â  Â  Â  Â  Â  Â  Â  lcd.setCursor(0, 1);
Â  Â  Â  Â  Â  Â  Â  Â  String stars = "";
Â  Â  Â  Â  Â  Â  Â  Â  for(int i=0; i<inputPassword.length(); i++) stars += "*";
Â  Â  Â  Â  Â  Â  Â  Â  lcd.print(stars);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  yield(); // Important for ESP8266 stability
}